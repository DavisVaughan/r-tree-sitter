[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 treesitter authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Davis Vaughan. Author, maintainer. . Copyright holder, funder. Tree-sitter authors. Copyright holder.           Tree-sitter C library","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vaughan D (2025). treesitter: Bindings 'Tree-Sitter'. R package version 0.2.0, https://github.com/DavisVaughan/r-tree-sitter.","code":"@Manual{,   title = {treesitter: Bindings to 'Tree-Sitter'},   author = {Davis Vaughan},   year = {2025},   note = {R package version 0.2.0},   url = {https://github.com/DavisVaughan/r-tree-sitter}, }"},{"path":"/index.html","id":"treesitter","dir":"","previous_headings":"","what":"Bindings to Tree-Sitter","title":"Bindings to Tree-Sitter","text":"treesitter provides R bindings tree-sitter, incremental parsing system. can build concrete syntax tree source file efficiently update syntax tree source file edited. tree-sitter useful number things, including syntax highlighting, go-definition, code reshaping, .","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bindings to Tree-Sitter","text":"Install treesitter CRAN : package provide bindings language specific tree-sitter grammar. fully utilize treesitter package, also need install grammar specific R package. Currently just one, R: can install development version treesitter GitHub :","code":"install.packages(\"treesitter\") install.packages(\"treesitter.r\") # install.packages(\"pak\") pak::pak(\"DavisVaughan/r-tree-sitter\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Bindings to Tree-Sitter","text":"treesitter, can parse string containing code language grammar . ’s example R code: Syntax trees can get pretty complex, ’s larger example: Trees nodes pretty nice print method colors matching parentheses dims locations. print tree R console, ’s ’d see:  treesitter number tools navigating around walking tree: default, printing node tree show anonymous nodes named nodes. Anonymous nodes help see full “concrete” syntax tree tree-sitter builds. want see something akin abstract syntax tree, can use node_show_s_expression(), number options customizing tree view:","code":"library(treesitter, warn.conflicts = FALSE)  # Language specific grammars come from extension packages language <- treesitter.r::language() parser <- parser(language)  # Imagine this is a source document text <- \" 1 + 2 \"  # Parse the text and display the resulting syntax tree parser_parse(parser, text) #> <tree_sitter_tree> #>  #> ── Text ──────────────────────────────────────────────────────────────────────── #>  #> 1 + 2 #>  #>  #> ── S-Expression ──────────────────────────────────────────────────────────────── #> (program [(0, 0), (2, 0)] #>   (binary_operator [(1, 0), (1, 5)] #>     lhs: (float [(1, 0), (1, 1)]) #>     operator: \"+\" [(1, 2), (1, 3)] #>     rhs: (float [(1, 4), (1, 5)]) #>   ) #> ) text <- \" mtcars |>   mutate(y = x + 1) \"  tree <- parser_parse(parser, text) # The right hand side of the pipe node <- tree |>   tree_root_node() |>   node_child(1) |>   node_child_by_field_name(\"rhs\")  node_text(node) #> [1] \"mutate(y = x + 1)\" # Full detail node_show_s_expression(node) #> (call [(2, 2), (2, 19)] #>   function: (identifier [(2, 2), (2, 8)]) #>   arguments: (arguments [(2, 8), (2, 19)] #>     open: \"(\" [(2, 8), (2, 9)] #>     argument: (argument [(2, 9), (2, 18)] #>       name: (identifier [(2, 9), (2, 10)]) #>       \"=\" [(2, 11), (2, 12)] #>       value: (binary_operator [(2, 13), (2, 18)] #>         lhs: (identifier [(2, 13), (2, 14)]) #>         operator: \"+\" [(2, 15), (2, 16)] #>         rhs: (float [(2, 17), (2, 18)]) #>       ) #>     ) #>     close: \")\" [(2, 18), (2, 19)] #>   ) #> )  # Compact view, more like an AST node_show_s_expression(   node,   show_anonymous = FALSE,   show_locations = FALSE,   dangling_parenthesis = FALSE ) #> (call #>   function: (identifier) #>   arguments: (arguments #>     argument: (argument #>       name: (identifier) #>       value: (binary_operator #>         lhs: (identifier) #>         rhs: (float)))))"},{"path":"/reference/TreeCursor.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree cursors — TreeCursor","title":"Tree cursors — TreeCursor","text":"TreeCursor R6 class allows walk tree efficient way calling node_*() functions like node_child() repeatedly. can also elegantly create cursor node_walk() tree_walk().","code":""},{"path":"/reference/TreeCursor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree cursors — TreeCursor","text":"R6 object representing tree cursor.","code":""},{"path":[]},{"path":"/reference/TreeCursor.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Tree cursors — TreeCursor","text":"TreeCursor$new() TreeCursor$reset() TreeCursor$node() TreeCursor$field_name() TreeCursor$field_id() TreeCursor$descendant_index() TreeCursor$goto_parent() TreeCursor$goto_next_sibling() TreeCursor$goto_previous_sibling() TreeCursor$goto_first_child() TreeCursor$goto_last_child() TreeCursor$depth() TreeCursor$goto_first_child_for_byte() TreeCursor$goto_first_child_for_point()","code":""},{"path":"/reference/TreeCursor.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Tree cursors — TreeCursor","text":"Create new tree cursor.","code":""},{"path":"/reference/TreeCursor.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$new(node)"},{"path":"/reference/TreeCursor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree cursors — TreeCursor","text":"node [tree_sitter_node] node start walking .","code":""},{"path":"/reference/TreeCursor.html","id":"method-reset-","dir":"Reference","previous_headings":"","what":"Method reset()","title":"Tree cursors — TreeCursor","text":"Reset tree cursor new root node.","code":""},{"path":"/reference/TreeCursor.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$reset(node)"},{"path":"/reference/TreeCursor.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree cursors — TreeCursor","text":"node [tree_sitter_node] node start walking .","code":""},{"path":"/reference/TreeCursor.html","id":"method-node-","dir":"Reference","previous_headings":"","what":"Method node()","title":"Tree cursors — TreeCursor","text":"Get current node cursor points .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$node()"},{"path":"/reference/TreeCursor.html","id":"method-field-name-","dir":"Reference","previous_headings":"","what":"Method field_name()","title":"Tree cursors — TreeCursor","text":"Get field name current node.","code":""},{"path":"/reference/TreeCursor.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$field_name()"},{"path":"/reference/TreeCursor.html","id":"method-field-id-","dir":"Reference","previous_headings":"","what":"Method field_id()","title":"Tree cursors — TreeCursor","text":"Get field id current node.","code":""},{"path":"/reference/TreeCursor.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$field_id()"},{"path":"/reference/TreeCursor.html","id":"method-descendant-index-","dir":"Reference","previous_headings":"","what":"Method descendant_index()","title":"Tree cursors — TreeCursor","text":"Get descendent index current node.","code":""},{"path":"/reference/TreeCursor.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$descendant_index()"},{"path":"/reference/TreeCursor.html","id":"method-goto-parent-","dir":"Reference","previous_headings":"","what":"Method goto_parent()","title":"Tree cursors — TreeCursor","text":"Go current node's parent. Returns TRUE parent found, FALSE .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$goto_parent()"},{"path":"/reference/TreeCursor.html","id":"method-goto-next-sibling-","dir":"Reference","previous_headings":"","what":"Method goto_next_sibling()","title":"Tree cursors — TreeCursor","text":"Go current node's next sibling. Returns TRUE sibling found, FALSE .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$goto_next_sibling()"},{"path":"/reference/TreeCursor.html","id":"method-goto-previous-sibling-","dir":"Reference","previous_headings":"","what":"Method goto_previous_sibling()","title":"Tree cursors — TreeCursor","text":"Go current node's previous sibling. Returns TRUE sibling found, FALSE .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$goto_previous_sibling()"},{"path":"/reference/TreeCursor.html","id":"method-goto-first-child-","dir":"Reference","previous_headings":"","what":"Method goto_first_child()","title":"Tree cursors — TreeCursor","text":"Go current node's first child. Returns TRUE child found, FALSE .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$goto_first_child()"},{"path":"/reference/TreeCursor.html","id":"method-goto-last-child-","dir":"Reference","previous_headings":"","what":"Method goto_last_child()","title":"Tree cursors — TreeCursor","text":"Go current node's last child. Returns TRUE child found, FALSE .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$goto_last_child()"},{"path":"/reference/TreeCursor.html","id":"method-depth-","dir":"Reference","previous_headings":"","what":"Method depth()","title":"Tree cursors — TreeCursor","text":"Get depth current node.","code":""},{"path":"/reference/TreeCursor.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$depth()"},{"path":"/reference/TreeCursor.html","id":"method-goto-first-child-for-byte-","dir":"Reference","previous_headings":"","what":"Method goto_first_child_for_byte()","title":"Tree cursors — TreeCursor","text":"Move cursor first child current node extends beyond given byte offset. Returns TRUE child found, FALSE .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$goto_first_child_for_byte(byte)"},{"path":"/reference/TreeCursor.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree cursors — TreeCursor","text":"byte [double(1)] byte move cursor past.","code":""},{"path":"/reference/TreeCursor.html","id":"method-goto-first-child-for-point-","dir":"Reference","previous_headings":"","what":"Method goto_first_child_for_point()","title":"Tree cursors — TreeCursor","text":"Move cursor first child current node extends beyond given point. Returns TRUE child found, FALSE .","code":""},{"path":"/reference/TreeCursor.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree cursors — TreeCursor","text":"","code":"TreeCursor$goto_first_child_for_point(point)"},{"path":"/reference/TreeCursor.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree cursors — TreeCursor","text":"point [tree_sitter_point] point move cursor past.","code":""},{"path":"/reference/TreeCursor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree cursors — TreeCursor","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function(a, b) { a + b }\"  tree <- parser_parse(parser, text) node <- tree_root_node(tree)  cursor <- TreeCursor$new(node)  cursor$node() #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function(a, b) { a + b } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 30)] #>   (binary_operator [(0, 0), (0, 30)] #>     lhs: (identifier [(0, 0), (0, 2)]) #>     operator: \"<-\" [(0, 3), (0, 5)] #>     rhs: (function_definition [(0, 6), (0, 30)] #>       name: \"function\" [(0, 6), (0, 14)] #>       parameters: (parameters [(0, 14), (0, 20)] #>         open: \"(\" [(0, 14), (0, 15)] #>         parameter: (parameter [(0, 15), (0, 16)] #>           name: (identifier [(0, 15), (0, 16)]) #>         ) #>         (comma [(0, 16), (0, 17)]) #>         parameter: (parameter [(0, 18), (0, 19)] #>           name: (identifier [(0, 18), (0, 19)]) #>         ) #>         close: \")\" [(0, 19), (0, 20)] #>       ) #>       body: (braced_expression [(0, 21), (0, 30)] #>         open: \"{\" [(0, 21), (0, 22)] #>         body: (binary_operator [(0, 23), (0, 28)] #>           lhs: (identifier [(0, 23), (0, 24)]) #>           operator: \"+\" [(0, 25), (0, 26)] #>           rhs: (identifier [(0, 27), (0, 28)]) #>         ) #>         close: \"}\" [(0, 29), (0, 30)] #> <truncated> cursor$goto_first_child() #> [1] TRUE cursor$goto_first_child() #> [1] TRUE cursor$node() #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)]) cursor$goto_next_sibling() #> [1] TRUE cursor$node() #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)]"},{"path":"/reference/is_language.html","id":null,"dir":"Reference","previous_headings":"","what":"Is x a language? — is_language","title":"Is x a language? — is_language","text":"Use is_language() determine object class \"tree_sitter_language\".","code":""},{"path":"/reference/is_language.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is x a language? — is_language","text":"","code":"is_language(x)"},{"path":"/reference/is_language.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is x a language? — is_language","text":"x [object] object.","code":""},{"path":"/reference/is_language.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is x a language? — is_language","text":"TRUE x \"tree_sitter_language\". FALSE otherwise.","code":""},{"path":"/reference/is_language.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is x a language? — is_language","text":"","code":"language <- treesitter.r::language() is_language(language) #> [1] TRUE"},{"path":"/reference/is_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Is x a node? — is_node","title":"Is x a node? — is_node","text":"Checks x tree_sitter_node .","code":""},{"path":"/reference/is_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is x a node? — is_node","text":"","code":"is_node(x)"},{"path":"/reference/is_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is x a node? — is_node","text":"x [object] object.","code":""},{"path":"/reference/is_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is x a node? — is_node","text":"TRUE x tree_sitter_node, otherwise FALSE.","code":""},{"path":"/reference/is_node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is x a node? — is_node","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  is_node(node) #> [1] TRUE  is_node(1) #> [1] FALSE"},{"path":"/reference/is_parser.html","id":null,"dir":"Reference","previous_headings":"","what":"Is x a parser? — is_parser","title":"Is x a parser? — is_parser","text":"Checks x tree_sitter_parser .","code":""},{"path":"/reference/is_parser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is x a parser? — is_parser","text":"","code":"is_parser(x)"},{"path":"/reference/is_parser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is x a parser? — is_parser","text":"x [object] object.","code":""},{"path":"/reference/is_parser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is x a parser? — is_parser","text":"TRUE x tree_sitter_parser, otherwise FALSE.","code":""},{"path":"/reference/is_parser.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is x a parser? — is_parser","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  is_parser(parser) #> [1] TRUE  is_parser(1) #> [1] FALSE"},{"path":"/reference/is_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Is x a query? — is_query","title":"Is x a query? — is_query","text":"Checks x tree_sitter_query .","code":""},{"path":"/reference/is_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is x a query? — is_query","text":"","code":"is_query(x)"},{"path":"/reference/is_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is x a query? — is_query","text":"x [object] object.","code":""},{"path":"/reference/is_query.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is x a query? — is_query","text":"TRUE x tree_sitter_query, otherwise FALSE.","code":""},{"path":"/reference/is_query.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is x a query? — is_query","text":"","code":"source <- \"(identifier) @id\" language <- treesitter.r::language()  query <- query(language, source)  is_query(query) #> [1] TRUE  is_query(1) #> [1] FALSE"},{"path":"/reference/is_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Is x a tree? — is_tree","title":"Is x a tree? — is_tree","text":"Checks x tree_sitter_tree .","code":""},{"path":"/reference/is_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is x a tree? — is_tree","text":"","code":"is_tree(x)"},{"path":"/reference/is_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is x a tree? — is_tree","text":"x [object] object.","code":""},{"path":"/reference/is_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is x a tree? — is_tree","text":"TRUE x tree_sitter_tree, otherwise FALSE.","code":""},{"path":"/reference/is_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is x a tree? — is_tree","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text)  is_tree(tree) #> [1] TRUE  is_tree(1) #> [1] FALSE"},{"path":"/reference/language_field_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Language field count — language_field_count","title":"Language field count — language_field_count","text":"Get number fields contained within language.","code":""},{"path":"/reference/language_field_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language field count — language_field_count","text":"","code":"language_field_count(x)"},{"path":"/reference/language_field_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language field count — language_field_count","text":"x [tree_sitter_language] tree-sitter language object.","code":""},{"path":"/reference/language_field_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language field count — language_field_count","text":"single double value.","code":""},{"path":"/reference/language_field_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language field count — language_field_count","text":"","code":"language <- treesitter.r::language() language_field_count(language) #> [1] 20"},{"path":"/reference/language_field_id_for_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Language field identifiers — language_field_id_for_name","title":"Language field identifiers — language_field_id_for_name","text":"Get integer field identifier field name. going using field name repeatedly, often little faster use corresponding field identifier instead.","code":""},{"path":"/reference/language_field_id_for_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language field identifiers — language_field_id_for_name","text":"","code":"language_field_id_for_name(x, name)"},{"path":"/reference/language_field_id_for_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language field identifiers — language_field_id_for_name","text":"x [tree_sitter_language] tree-sitter language object. name [character] language field names look field identifiers .","code":""},{"path":"/reference/language_field_id_for_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language field identifiers — language_field_id_for_name","text":"integer vector length name containing: field identifier field name, known. NA, field name known.","code":""},{"path":[]},{"path":"/reference/language_field_id_for_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language field identifiers — language_field_id_for_name","text":"","code":"language <- treesitter.r::language() language_field_id_for_name(language, \"lhs\") #> [1] 11"},{"path":"/reference/language_field_name_for_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Language field names — language_field_name_for_id","title":"Language field names — language_field_name_for_id","text":"Get field name field identifier.","code":""},{"path":"/reference/language_field_name_for_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language field names — language_field_name_for_id","text":"","code":"language_field_name_for_id(x, id)"},{"path":"/reference/language_field_name_for_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language field names — language_field_name_for_id","text":"x [tree_sitter_language] tree-sitter language object. id [integer] language field identifiers look field names .","code":""},{"path":"/reference/language_field_name_for_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language field names — language_field_name_for_id","text":"character vector length id containing: field name field identifier, known. NA, field identifier known.","code":""},{"path":[]},{"path":"/reference/language_field_name_for_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language field names — language_field_name_for_id","text":"","code":"language <- treesitter.r::language() language_field_name_for_id(language, 1) #> [1] \"alternative\""},{"path":"/reference/language_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Language name — language_name","title":"Language name — language_name","text":"Extract language object's language name.","code":""},{"path":"/reference/language_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language name — language_name","text":"","code":"language_name(x)"},{"path":"/reference/language_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language name — language_name","text":"x [tree_sitter_language] tree-sitter language object.","code":""},{"path":"/reference/language_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language name — language_name","text":"string.","code":""},{"path":"/reference/language_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language name — language_name","text":"","code":"language <- treesitter.r::language() language_name(language) #> [1] \"r\""},{"path":"/reference/language_next_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Language state advancement — language_next_state","title":"Language state advancement — language_next_state","text":"Get next state grammar.","code":""},{"path":"/reference/language_next_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language state advancement — language_next_state","text":"","code":"language_next_state(x, state, symbol)"},{"path":"/reference/language_next_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language state advancement — language_next_state","text":"x [tree_sitter_language] tree-sitter language object. state, symbol [integer] Vectors equal length containing current state symbol information.","code":""},{"path":"/reference/language_next_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language state advancement — language_next_state","text":"single integer representing next state.","code":""},{"path":"/reference/language_next_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language state advancement — language_next_state","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to function definition node <- node_child(node, 1) node <- node_child(node, 3) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> )  state <- node_parse_state(node) symbol <- node_grammar_symbol(node)  # Function definition symbol language_symbol_name(language, 85) #> [1] \"_parameter_without_default\"  # Next state (this is all grammar dependent) language_next_state(language, state, symbol) #> [1] 443"},{"path":"/reference/language_state_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Language state count — language_state_count","title":"Language state count — language_state_count","text":"Get number states traversable within language.","code":""},{"path":"/reference/language_state_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language state count — language_state_count","text":"","code":"language_state_count(x)"},{"path":"/reference/language_state_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language state count — language_state_count","text":"x [tree_sitter_language] tree-sitter language object.","code":""},{"path":"/reference/language_state_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language state count — language_state_count","text":"single double value.","code":""},{"path":"/reference/language_state_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language state count — language_state_count","text":"","code":"language <- treesitter.r::language() language_state_count(language) #> [1] 2199"},{"path":"/reference/language_symbol_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Language symbol count — language_symbol_count","title":"Language symbol count — language_symbol_count","text":"Get number symbols contained within language.","code":""},{"path":"/reference/language_symbol_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language symbol count — language_symbol_count","text":"","code":"language_symbol_count(x)"},{"path":"/reference/language_symbol_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language symbol count — language_symbol_count","text":"x [tree_sitter_language] tree-sitter language object.","code":""},{"path":"/reference/language_symbol_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language symbol count — language_symbol_count","text":"single double value.","code":""},{"path":"/reference/language_symbol_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language symbol count — language_symbol_count","text":"","code":"language <- treesitter.r::language() language_symbol_count(language) #> [1] 136"},{"path":"/reference/language_symbol_for_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Language symbols — language_symbol_for_name","title":"Language symbols — language_symbol_for_name","text":"Get integer symbol ID particular node name. Can useful exploring grammar.","code":""},{"path":"/reference/language_symbol_for_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language symbols — language_symbol_for_name","text":"","code":"language_symbol_for_name(x, name, ..., named = TRUE)"},{"path":"/reference/language_symbol_for_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language symbols — language_symbol_for_name","text":"x [tree_sitter_language] tree-sitter language object. name [character] names look symbols . ... dots future extensions must empty. named [logical] named anonymous nodes looked ? Recycled size name.","code":""},{"path":"/reference/language_symbol_for_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language symbols — language_symbol_for_name","text":"integer vector size name containing either: integer symbol ID node name, known. NA node name known.","code":""},{"path":[]},{"path":"/reference/language_symbol_for_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language symbols — language_symbol_for_name","text":"","code":"language <- treesitter.r::language() language_symbol_for_name(language, \"identifier\") #> [1] 1"},{"path":"/reference/language_symbol_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Language symbol names — language_symbol_name","title":"Language symbol names — language_symbol_name","text":"Get name particular language symbol ID. Can useful exploring grammar.","code":""},{"path":"/reference/language_symbol_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Language symbol names — language_symbol_name","text":"","code":"language_symbol_name(x, symbol)"},{"path":"/reference/language_symbol_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Language symbol names — language_symbol_name","text":"x [tree_sitter_language] tree-sitter language object. symbol [positive integer] language symbols look names .","code":""},{"path":"/reference/language_symbol_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Language symbol names — language_symbol_name","text":"character vector length symbol containing: name symbol, known. NA, symbol known.","code":""},{"path":[]},{"path":"/reference/language_symbol_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Language symbol names — language_symbol_name","text":"","code":"language <- treesitter.r::language() language_symbol_name(language, 1) #> [1] \"identifier\""},{"path":"/reference/node-child-by-field.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a node's child by field id or name — node-child-by-field","title":"Get a node's child by field id or name — node-child-by-field","text":"functions return children x field id name. node_child_by_field_id() retrieves child field id. node_child_by_field_name() retrieves child field name. Use language_field_id_for_name() get field id field name.","code":""},{"path":"/reference/node-child-by-field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a node's child by field id or name — node-child-by-field","text":"","code":"node_child_by_field_id(x, id)  node_child_by_field_name(x, name)"},{"path":"/reference/node-child-by-field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a node's child by field id or name — node-child-by-field","text":"x [tree_sitter_node] node. id [integer(1)] field id child return. name [character(1)] field name child return.","code":""},{"path":"/reference/node-child-by-field.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a node's child by field id or name — node-child-by-field","text":"child x, NULL matching child can found.","code":""},{"path":"/reference/node-child-by-field.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a node's child by field id or name — node-child-by-field","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to first child node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )  # Get the field name of the first child name <- node_field_name_for_child(node, 1) name #> [1] \"lhs\"  # Now get the child again by that field name node_child_by_field_name(node, name) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)])  # If you need to look up by field name many times, you can look up the # more direct field id first and use that instead id <- language_field_id_for_name(language, name) id #> [1] 11  node_child_by_field_id(node, id) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)])  # Returns `NULL` if no matching child node_child_by_field_id(node, 10000) #> NULL"},{"path":"/reference/node-child-count.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a node's child count — node-child-count","title":"Get a node's child count — node-child-count","text":"functions return number children x. node_child_count() considers named anonymous children. node_named_child_count() considers named children.","code":""},{"path":"/reference/node-child-count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a node's child count — node-child-count","text":"","code":"node_child_count(x)  node_named_child_count(x)"},{"path":"/reference/node-child-count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a node's child count — node-child-count","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node-child-count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a node's child count — node-child-count","text":"single integer, number children x.","code":""},{"path":"/reference/node-child-count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a node's child count — node-child-count","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to first child node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )  # Note how the named variant doesn't count the anonymous operator node node_child_count(node) #> [1] 3 node_named_child_count(node) #> [1] 2"},{"path":"/reference/node-child.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a node's child by index — node-child","title":"Get a node's child by index — node-child","text":"functions return ith child x. node_child() considers named anonymous children. node_named_child() considers named children.","code":""},{"path":"/reference/node-child.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a node's child by index — node-child","text":"","code":"node_child(x, i)  node_named_child(x, i)"},{"path":"/reference/node-child.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a node's child by index — node-child","text":"x [tree_sitter_node] node. [integer(1)] index child return.","code":""},{"path":"/reference/node-child.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a node's child by index — node-child","text":"ith child node x NULL child index.","code":""},{"path":"/reference/node-child.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a node's child by index — node-child","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Starts with `program` node for the whole document node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 26)] #>   (binary_operator [(0, 0), (0, 26)] #>     lhs: (identifier [(0, 0), (0, 2)]) #>     operator: \"<-\" [(0, 3), (0, 5)] #>     rhs: (function_definition [(0, 6), (0, 26)] #>       name: \"function\" [(0, 6), (0, 14)] #>       parameters: (parameters [(0, 14), (0, 16)] #>         open: \"(\" [(0, 14), (0, 15)] #>         close: \")\" [(0, 15), (0, 16)] #>       ) #>       body: (braced_expression [(0, 17), (0, 26)] #>         open: \"{\" [(0, 17), (0, 18)] #>         body: (binary_operator [(0, 19), (0, 24)] #>           lhs: (float [(0, 19), (0, 20)]) #>           operator: \"+\" [(0, 21), (0, 22)] #>           rhs: (float [(0, 23), (0, 24)]) #>         ) #>         close: \"}\" [(0, 25), (0, 26)] #>       ) #>     ) #>   ) #> )  # Navigate to first child node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )  # Note how the named variant skips the anonymous operator node node_child(node, 2) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)] node_named_child(node, 2) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> )  # OOB indices return `NULL` node_child(node, 5) #> NULL"},{"path":"/reference/node-children.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a node's children — node-children","title":"Get a node's children — node-children","text":"functions return children x within list. node_children() considers named anonymous children. node_named_children() considers named children.","code":""},{"path":"/reference/node-children.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a node's children — node-children","text":"","code":"node_children(x)  node_named_children(x)"},{"path":"/reference/node-children.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a node's children — node-children","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node-children.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a node's children — node-children","text":"children x list.","code":""},{"path":"/reference/node-children.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a node's children — node-children","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to first child node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )  # Note how the named variant doesn't include the anonymous operator node node_children(node) #> [[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)]) #>  #> [[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)] #>  #> [[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> ) #>  node_named_children(node) #> [[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)]) #>  #> [[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> ) #>"},{"path":"/reference/node-descendant.html","id":null,"dir":"Reference","previous_headings":"","what":"Node descendants — node-descendant","title":"Node descendants — node-descendant","text":"functions return smallest node within node spans given range bytes points. ranges bounds, smaller node can determined, input returned.","code":""},{"path":"/reference/node-descendant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node descendants — node-descendant","text":"","code":"node_descendant_for_byte_range(x, start, end)  node_named_descendant_for_byte_range(x, start, end)  node_descendant_for_point_range(x, start, end)  node_named_descendant_for_point_range(x, start, end)"},{"path":"/reference/node-descendant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node descendants — node-descendant","text":"x [tree_sitter_node] node. start, end [integer(1) / tree_sitter_point] byte range functions, start end bytes search within. point range functions, start end points created point() search within.","code":""},{"path":"/reference/node-descendant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node descendants — node-descendant","text":"node.","code":""},{"path":"/reference/node-descendant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node descendants — node-descendant","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # The whole `<-` binary operator node node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )  # The byte range points to a location in the word `function` node_descendant_for_byte_range(node, 7, 9) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"function\" [(0, 6), (0, 14)] node_named_descendant_for_byte_range(node, 7, 9) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> )  start <- point(0, 14) end <- point(0, 15)  node_descendant_for_point_range(node, start, end) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> ( #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"(\" [(0, 14), (0, 15)] node_named_descendant_for_point_range(node, start, end) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> () #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (parameters [(0, 14), (0, 16)] #>   open: \"(\" [(0, 14), (0, 15)] #>   close: \")\" [(0, 15), (0, 16)] #> )  # OOB returns the input node_descendant_for_byte_range(node, 25, 29) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )"},{"path":"/reference/node-first-child-byte.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the first child that extends beyond the given byte offset — node-first-child-byte","title":"Get the first child that extends beyond the given byte offset — node-first-child-byte","text":"functions return first child x extends beyond given byte offset. Note byte 0-indexed offset. node_first_child_for_byte() considers named anonymous nodes. node_first_named_child_for_byte() considers named nodes.","code":""},{"path":"/reference/node-first-child-byte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the first child that extends beyond the given byte offset — node-first-child-byte","text":"","code":"node_first_child_for_byte(x, byte)  node_first_named_child_for_byte(x, byte)"},{"path":"/reference/node-first-child-byte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the first child that extends beyond the given byte offset — node-first-child-byte","text":"x [tree_sitter_node] node. byte [integer(1)] byte start search . Note byte 0-indexed!","code":""},{"path":"/reference/node-first-child-byte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the first child that extends beyond the given byte offset — node-first-child-byte","text":"new node, NULL node past byte offset.","code":""},{"path":"/reference/node-first-child-byte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the first child that extends beyond the given byte offset — node-first-child-byte","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to first child node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )  # `fn {here}<- function()` node_first_child_for_byte(node, 3) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)] node_first_named_child_for_byte(node, 3) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> )  # Past any node node_first_child_for_byte(node, 100) #> NULL"},{"path":"/reference/node-grammar.html","id":null,"dir":"Reference","previous_headings":"","what":"Node grammar types and symbols — node-grammar","title":"Node grammar types and symbols — node-grammar","text":"node_grammar_type() gets node's type appears grammar, ignoring aliases. node_grammar_symbol() gets node's symbol (type numeric id) appears grammar, ignoring aliases. used language_next_state() rather node_symbol().","code":""},{"path":"/reference/node-grammar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node grammar types and symbols — node-grammar","text":"","code":"node_grammar_type(x)  node_grammar_symbol(x)"},{"path":"/reference/node-grammar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node grammar types and symbols — node-grammar","text":"x [tree_sitter_node] node.","code":""},{"path":[]},{"path":"/reference/node-grammar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node grammar types and symbols — node-grammar","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Examples for these functions are highly specific to the grammar, # because they relies on the placement of `alias()` calls in the grammar. node_grammar_type(node) #> [1] \"program\" node_grammar_symbol(node) #> [1] 80"},{"path":"/reference/node-location.html","id":null,"dir":"Reference","previous_headings":"","what":"Node byte and point accessors — node-location","title":"Node byte and point accessors — node-location","text":"functions return information location x document. byte, row, column locations 0-indexed. node_start_byte() returns start byte. node_end_byte() returns end byte. node_start_point() returns start point, containing row column location within document. Use accessors like point_row() extract row column positions. node_end_point() returns end point, containing row column location within document. Use accessors like point_row() extract row column positions. node_range() returns range object contains information. Use accessors like range_start_point() extract individual pieces range.","code":""},{"path":"/reference/node-location.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node byte and point accessors — node-location","text":"","code":"node_start_byte(x)  node_end_byte(x)  node_start_point(x)  node_end_point(x)  node_range(x)"},{"path":"/reference/node-location.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node byte and point accessors — node-location","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node-location.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node byte and point accessors — node-location","text":"node_start_byte() node_end_byte() return single numeric value. node_start_point() node_end_point() return single points. node_range() returns range.","code":""},{"path":"/reference/node-location.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node byte and point accessors — node-location","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to first child node <- node_child(node, 1)  # Navigate to function definition node node <- node_child(node, 3) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> )  node_start_byte(node) #> [1] 6 node_end_byte(node) #> [1] 26  node_start_point(node) #> <tree_sitter_point> #> Row: 0 #> Column: 6 node_end_point(node) #> <tree_sitter_point> #> Row: 0 #> Column: 26  node_range(node) #> <tree_sitter_range> #> Start <byte: 6, row: 0, column: 6> #> End <byte: 26, row: 0, column: 26>"},{"path":"/reference/node-metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Node metadata — node-metadata","title":"Node metadata — node-metadata","text":"functions return metadata current node. node_is_named() reports current node named anonymous. node_is_missing() reports current node MISSING, .e. implied error recovery. node_is_extra() reports current node \"extra\" grammar. node_is_error() reports current node ERROR node. node_has_error() reports current node ERROR node, descendants current node ERROR MISSING nodes.","code":""},{"path":"/reference/node-metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node metadata — node-metadata","text":"","code":"node_is_named(x)  node_is_missing(x)  node_is_extra(x)  node_is_error(x)  node_has_error(x)"},{"path":"/reference/node-metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node metadata — node-metadata","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node-metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node metadata — node-metadata","text":"TRUE FALSE.","code":""},{"path":"/reference/node-metadata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node metadata — node-metadata","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  node <- node_child(node, 1)  fn <- node_child(node, 1) operator <- node_child(node, 2)  fn #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)]) node_is_named(fn) #> [1] TRUE  operator #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)] node_is_named(operator) #> [1] FALSE  # Examples of `TRUE` cases for these are a bit hard to come up with, because # they are dependent on the exact state of the grammar and the error recovery # algorithm node_is_missing(node) #> [1] FALSE node_is_extra(node) #> [1] FALSE"},{"path":"/reference/node-parse-state.html","id":null,"dir":"Reference","previous_headings":"","what":"Node parse states — node-parse-state","title":"Node parse states — node-parse-state","text":"advanced functions return information internal parse states. node_parse_state() returns parse state current node. node_next_parse_state() returns parse state node. See language_next_state() information.","code":""},{"path":"/reference/node-parse-state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node parse states — node-parse-state","text":"","code":"node_parse_state(x)  node_next_parse_state(x)"},{"path":"/reference/node-parse-state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node parse states — node-parse-state","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node-parse-state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node parse states — node-parse-state","text":"single integer representing parse state.","code":""},{"path":"/reference/node-parse-state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node parse states — node-parse-state","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  node <- node_child(node, 1)  # Parse states are grammar dependent node_parse_state(node) #> [1] 1 node_next_parse_state(node) #> [1] 364"},{"path":"/reference/node-sibling.html","id":null,"dir":"Reference","previous_headings":"","what":"Node sibling accessors — node-sibling","title":"Node sibling accessors — node-sibling","text":"functions return siblings current node, .e. looked \"left\" \"right\" current node rather \"\" (parent) \"\" (child). node_next_sibling() node_next_named_sibling() return next sibling. node_previous_sibling() node_previous_named_sibling() return previous sibling.","code":""},{"path":"/reference/node-sibling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node sibling accessors — node-sibling","text":"","code":"node_next_sibling(x)  node_next_named_sibling(x)  node_previous_sibling(x)  node_previous_named_sibling(x)"},{"path":"/reference/node-sibling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node sibling accessors — node-sibling","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node-sibling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node sibling accessors — node-sibling","text":"sibling node, NULL sibling node.","code":""},{"path":"/reference/node-sibling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node sibling accessors — node-sibling","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to first child node <- node_child(node, 1)  # Navigate to function definition node node <- node_child(node, 3) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> )  node_previous_sibling(node) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)]  # Skip anonymous operator node node_previous_named_sibling(node) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)])  # There isn't one! node_next_sibling(node) #> NULL"},{"path":"/reference/node_descendant_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Node descendant count — node_descendant_count","title":"Node descendant count — node_descendant_count","text":"Returns number descendants node, including node count.","code":""},{"path":"/reference/node_descendant_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node descendant count — node_descendant_count","text":"","code":"node_descendant_count(x)"},{"path":"/reference/node_descendant_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node descendant count — node_descendant_count","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_descendant_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node descendant count — node_descendant_count","text":"single double.","code":""},{"path":"/reference/node_descendant_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node descendant count — node_descendant_count","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Top level program node node_descendant_count(node) #> [1] 16  # The whole `<-` binary operator node node <- node_child(node, 1) node_descendant_count(node) #> [1] 15  # Just the literal `<-` operator itself node <- node_child_by_field_name(node, \"operator\") node_descendant_count(node) #> [1] 1"},{"path":"/reference/node_field_name_for_child.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a child's field name by index — node_field_name_for_child","title":"Get a child's field name by index — node_field_name_for_child","text":"node_field_name_for_child() returns field name ith child, considering named anonymous nodes. Nodes know field names, know fields . must access parents query field names.","code":""},{"path":"/reference/node_field_name_for_child.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a child's field name by index — node_field_name_for_child","text":"","code":"node_field_name_for_child(x, i)"},{"path":"/reference/node_field_name_for_child.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a child's field name by index — node_field_name_for_child","text":"x [tree_sitter_node] node. [integer(1)] index child get field name .","code":""},{"path":"/reference/node_field_name_for_child.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a child's field name by index — node_field_name_for_child","text":"field name ith child x, NA_character_ child exist.","code":""},{"path":"/reference/node_field_name_for_child.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a child's field name by index — node_field_name_for_child","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Navigate to first child node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )  # Get the field name of the first few children (note that anonymous children # are considered) node_field_name_for_child(node, 1) #> [1] \"lhs\" node_field_name_for_child(node, 2) #> [1] \"operator\"  # 10th child doesn't exist, this returns `NA_character_` node_field_name_for_child(node, 10) #> [1] NA"},{"path":"/reference/node_language.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a node's underlying language — node_language","title":"Get a node's underlying language — node_language","text":"node_language() returns document text underlying node.","code":""},{"path":"/reference/node_language.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a node's underlying language — node_language","text":"","code":"node_language(x)"},{"path":"/reference/node_language.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a node's underlying language — node_language","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_language.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a node's underlying language — node_language","text":"tree_sitter_language object.","code":""},{"path":"/reference/node_language.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a node's underlying language — node_language","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"1 + foo\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  node_language(node) #> <tree_sitter_language> #> Language: r"},{"path":"/reference/node_parent.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a node's parent — node_parent","title":"Get a node's parent — node_parent","text":"node_parent() looks tree returns current node's parent.","code":""},{"path":"/reference/node_parent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a node's parent — node_parent","text":"","code":"node_parent(x)"},{"path":"/reference/node_parent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a node's parent — node_parent","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_parent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a node's parent — node_parent","text":"parent node x NULL parent.","code":""},{"path":"/reference/node_parent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a node's parent — node_parent","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Parent of a root node is `NULL` node_parent(node) #> NULL  node_function <- node |>   node_child(1) |>   node_child(3)  node_function #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> )  node_parent(node_function) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> )"},{"path":"/reference/node_raw_s_expression.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"node_raw_s_expression() returns \"raw\" s-expression seen tree-sitter. time, node_show_s_expression() provides better view tree, occasionally can useful see exactly underlying C library using.","code":""},{"path":"/reference/node_raw_s_expression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"node_raw_s_expression(x)"},{"path":"/reference/node_raw_s_expression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_raw_s_expression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"single string containing raw s-expression.","code":""},{"path":"/reference/node_raw_s_expression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"1 + foo\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  node_raw_s_expression(node) #> [1] \"(program (binary_operator lhs: (float) rhs: (identifier)))\""},{"path":"/reference/node_show_s_expression.html","id":null,"dir":"Reference","previous_headings":"","what":"Pretty print a node's s-expression — node_show_s_expression","title":"Pretty print a node's s-expression — node_show_s_expression","text":"node_show_s_expression() prints nicely formatted s-expression console. powers print methods nodes trees.","code":""},{"path":"/reference/node_show_s_expression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pretty print a node's s-expression — node_show_s_expression","text":"","code":"node_show_s_expression(   x,   ...,   max_lines = NULL,   show_anonymous = TRUE,   show_locations = TRUE,   show_parentheses = TRUE,   dangling_parenthesis = TRUE,   color_parentheses = TRUE,   color_locations = TRUE )"},{"path":"/reference/node_show_s_expression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pretty print a node's s-expression — node_show_s_expression","text":"x [tree_sitter_node] node. ... dots future extensions must empty. max_lines [double(1) / NULL] optional maximum number lines print. maximum hit, <truncated> printed end. show_anonymous [bool] anonymous nodes shown? FALSE, named nodes shown. show_locations [bool] node locations shown? show_parentheses [bool] parentheses around node shown? dangling_parenthesis [bool] ) parenthesis \"dangle\" line? FALSE, appended line containing last child. can useful conserving space. color_parentheses [bool] parentheses colored? Printing large s-expressions faster set FALSE. color_locations [bool] locations colored? Printing large s-expressions faster set FALSE.","code":""},{"path":"/reference/node_show_s_expression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pretty print a node's s-expression — node_show_s_expression","text":"x invisibly.","code":""},{"path":"/reference/node_show_s_expression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pretty print a node's s-expression — node_show_s_expression","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function(a, b = 2) { a + b + 2 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  node_show_s_expression(node) #> (program [(0, 0), (0, 38)] #>   (binary_operator [(0, 0), (0, 38)] #>     lhs: (identifier [(0, 0), (0, 2)]) #>     operator: \"<-\" [(0, 3), (0, 5)] #>     rhs: (function_definition [(0, 6), (0, 38)] #>       name: \"function\" [(0, 6), (0, 14)] #>       parameters: (parameters [(0, 14), (0, 24)] #>         open: \"(\" [(0, 14), (0, 15)] #>         parameter: (parameter [(0, 15), (0, 16)] #>           name: (identifier [(0, 15), (0, 16)]) #>         ) #>         (comma [(0, 16), (0, 17)]) #>         parameter: (parameter [(0, 18), (0, 23)] #>           name: (identifier [(0, 18), (0, 19)]) #>           \"=\" [(0, 20), (0, 21)] #>           default: (float [(0, 22), (0, 23)]) #>         ) #>         close: \")\" [(0, 23), (0, 24)] #>       ) #>       body: (braced_expression [(0, 25), (0, 38)] #>         open: \"{\" [(0, 25), (0, 26)] #>         body: (binary_operator [(0, 27), (0, 36)] #>           lhs: (binary_operator [(0, 27), (0, 32)] #>             lhs: (identifier [(0, 27), (0, 28)]) #>             operator: \"+\" [(0, 29), (0, 30)] #>             rhs: (identifier [(0, 31), (0, 32)]) #>           ) #>           operator: \"+\" [(0, 33), (0, 34)] #>           rhs: (float [(0, 35), (0, 36)]) #>         ) #>         close: \"}\" [(0, 37), (0, 38)] #>       ) #>     ) #>   ) #> )  node_show_s_expression(node, max_lines = 5) #> (program [(0, 0), (0, 38)] #>   (binary_operator [(0, 0), (0, 38)] #>     lhs: (identifier [(0, 0), (0, 2)]) #>     operator: \"<-\" [(0, 3), (0, 5)] #>     rhs: (function_definition [(0, 6), (0, 38)] #> <truncated>  # This is more like a typical abstract syntax tree node_show_s_expression(   node,   show_anonymous = FALSE,   show_locations = FALSE,   dangling_parenthesis = FALSE ) #> (program #>   (binary_operator #>     lhs: (identifier) #>     rhs: (function_definition #>       parameters: (parameters #>         parameter: (parameter #>           name: (identifier)) #>         (comma) #>         parameter: (parameter #>           name: (identifier) #>           default: (float))) #>       body: (braced_expression #>         body: (binary_operator #>           lhs: (binary_operator #>             lhs: (identifier) #>             rhs: (identifier)) #>           rhs: (float))))))"},{"path":"/reference/node_symbol.html","id":null,"dir":"Reference","previous_headings":"","what":"Node symbol — node_symbol","title":"Node symbol — node_symbol","text":"node_symbol() returns symbol id current node integer.","code":""},{"path":"/reference/node_symbol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node symbol — node_symbol","text":"","code":"node_symbol(x)"},{"path":"/reference/node_symbol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node symbol — node_symbol","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_symbol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node symbol — node_symbol","text":"single integer.","code":""},{"path":"/reference/node_symbol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node symbol — node_symbol","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Top level program node node_symbol(node) #> [1] 80  # The whole `<-` binary operator node node <- node_child(node, 1) node_symbol(node) #> [1] 104  # Just the literal `<-` operator itself node <- node_child_by_field_name(node, \"operator\") node_symbol(node) #> [1] 15"},{"path":"/reference/node_text.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a node's underlying text — node_text","title":"Get a node's underlying text — node_text","text":"node_text() returns document text underlying node.","code":""},{"path":"/reference/node_text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a node's underlying text — node_text","text":"","code":"node_text(x)"},{"path":"/reference/node_text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a node's underlying text — node_text","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_text.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a node's underlying text — node_text","text":"single string containing node's text.","code":""},{"path":"/reference/node_text.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a node's underlying text — node_text","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"1 + foo\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  node |>   node_child(1) |>   node_child_by_field_name(\"rhs\") |>   node_text() #> [1] \"foo\""},{"path":"/reference/node_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Node type — node_type","title":"Node type — node_type","text":"node_type() returns \"type\" current node string. useful function making decisions handle current node.","code":""},{"path":"/reference/node_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Node type — node_type","text":"","code":"node_type(x)"},{"path":"/reference/node_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Node type — node_type","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Node type — node_type","text":"single string.","code":""},{"path":"/reference/node_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Node type — node_type","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Top level program node node_type(node) #> [1] \"program\"  # The whole `<-` binary operator node node <- node_child(node, 1) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(0, 0), (0, 26)] #>   lhs: (identifier [(0, 0), (0, 2)]) #>   operator: \"<-\" [(0, 3), (0, 5)] #>   rhs: (function_definition [(0, 6), (0, 26)] #>     name: \"function\" [(0, 6), (0, 14)] #>     parameters: (parameters [(0, 14), (0, 16)] #>       open: \"(\" [(0, 14), (0, 15)] #>       close: \")\" [(0, 15), (0, 16)] #>     ) #>     body: (braced_expression [(0, 17), (0, 26)] #>       open: \"{\" [(0, 17), (0, 18)] #>       body: (binary_operator [(0, 19), (0, 24)] #>         lhs: (float [(0, 19), (0, 20)]) #>         operator: \"+\" [(0, 21), (0, 22)] #>         rhs: (float [(0, 23), (0, 24)]) #>       ) #>       close: \"}\" [(0, 25), (0, 26)] #>     ) #>   ) #> ) node_type(node) #> [1] \"binary_operator\"  # Just the literal `<-` operator itself node <- node_child_by_field_name(node, \"operator\") node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)] node_type(node) #> [1] \"<-\""},{"path":"/reference/node_walk.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a TreeCursor iterator — node_walk","title":"Generate a TreeCursor iterator — node_walk","text":"node_walk() creates TreeCursor starting current node. can use \"walk\" tree efficiently using node_child() similar node functions.","code":""},{"path":"/reference/node_walk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a TreeCursor iterator — node_walk","text":"","code":"node_walk(x)"},{"path":"/reference/node_walk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a TreeCursor iterator — node_walk","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/node_walk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a TreeCursor iterator — node_walk","text":"TreeCursor object.","code":""},{"path":"/reference/node_walk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a TreeCursor iterator — node_walk","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"1 + foo\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  cursor <- node_walk(node)  cursor$goto_first_child() #> [1] TRUE cursor$goto_first_child() #> [1] TRUE cursor$node() #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> 1 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (float [(0, 0), (0, 1)]) cursor$goto_next_sibling() #> [1] TRUE cursor$node() #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> + #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"+\" [(0, 2), (0, 3)]"},{"path":"/reference/parser-adjustments.html","id":null,"dir":"Reference","previous_headings":"","what":"Parser adjustments — parser-adjustments","title":"Parser adjustments — parser-adjustments","text":"parser_set_language() sets language parser. usually done parser() though. parser_set_timeout() sets optional timeout used calling parser_parse() parser_reparse(). timeout hit, error occurs. parser_set_included_ranges() sets optional list ranges locations considered parsing. ranges created range().","code":""},{"path":"/reference/parser-adjustments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parser adjustments — parser-adjustments","text":"","code":"parser_set_language(x, language)  parser_set_timeout(x, timeout)  parser_set_included_ranges(x, included_ranges)"},{"path":"/reference/parser-adjustments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parser adjustments — parser-adjustments","text":"x [tree_sitter_parser] parser. language [tree_sitter_language] language. timeout [double(1)] single whole number corresponding timeout microseconds use parsing. included_ranges [list_of<tree_sitter_range>] list ranges constructed range(). locations considered parsing. empty list can used clear existing ranges parser parse entire document.","code":""},{"path":"/reference/parser-adjustments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parser adjustments — parser-adjustments","text":"new parser.","code":""},{"path":"/reference/parser-adjustments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parser adjustments — parser-adjustments","text":"","code":"language <- treesitter.r::language() parser <- parser(language) parser_set_timeout(parser, 10000) #> <tree_sitter_parser> #> Language: r"},{"path":"/reference/parser-parse.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse or reparse text — parser-parse","title":"Parse or reparse text — parser-parse","text":"parser_parse() performs initial parse text, string typically containing contents file. returns tree manipulations. parser_reparse() performs fast incremental reparse. text typically slightly modified version original text new \"edit\" applied. position edit described byte point arguments function. tree argument corresponds original tree returned parser_parse(). bytes points 0-indexed.","code":""},{"path":"/reference/parser-parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse or reparse text — parser-parse","text":"","code":"parser_parse(x, text, ..., encoding = \"UTF-8\")  parser_reparse(   x,   text,   tree,   start_byte,   start_point,   old_end_byte,   old_end_point,   new_end_byte,   new_end_point,   ...,   encoding = \"UTF-8\" )"},{"path":"/reference/parser-parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse or reparse text — parser-parse","text":"x [tree_sitter_parser] parser. text [string] text parse. ... dots future extensions must empty. encoding [string] expected encoding text. Either \"UTF-8\" \"UTF-16\". tree [tree_sitter_tree] original tree returned parser_parse(). Components tree reused perform incremental reparse. start_byte, start_point [double(1) / tree_sitter_point] starting byte starting point edit location. old_end_byte, old_end_point [double(1) / tree_sitter_point] old ending byte old ending point edit location. new_end_byte, new_end_point [double(1) / tree_sitter_point] new ending byte new ending point edit location.","code":""},{"path":"/reference/parser-parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse or reparse text — parser-parse","text":"new tree.","code":""},{"path":"/reference/parser-parse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse or reparse text — parser-parse","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"1 + foo\" tree <- parser_parse(parser, text) tree #> <tree_sitter_tree> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> 1 + foo #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 7)] #>   (binary_operator [(0, 0), (0, 7)] #>     lhs: (float [(0, 0), (0, 1)]) #>     operator: \"+\" [(0, 2), (0, 3)] #>     rhs: (identifier [(0, 4), (0, 7)]) #>   ) #> )  text <- \"1 + bar(foo)\" parser_reparse(   parser,   text,   tree,   start_byte = 4,   start_point = point(0, 4),   old_end_byte = 7,   old_end_point = point(0, 7),   new_end_byte = 12,   new_end_point = point(0, 12) ) #> <tree_sitter_tree> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> 1 + bar(foo) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 12)] #>   (binary_operator [(0, 0), (0, 12)] #>     lhs: (float [(0, 0), (0, 1)]) #>     operator: \"+\" [(0, 2), (0, 3)] #>     rhs: (call [(0, 4), (0, 12)] #>       function: (identifier [(0, 4), (0, 7)]) #>       arguments: (arguments [(0, 7), (0, 12)] #>         open: \"(\" [(0, 7), (0, 8)] #>         argument: (argument [(0, 8), (0, 11)] #>           value: (identifier [(0, 8), (0, 11)]) #>         ) #>         close: \")\" [(0, 11), (0, 12)] #>       ) #>     ) #>   ) #> )"},{"path":"/reference/parser.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new parser — parser","title":"Create a new parser — parser","text":"parser() constructs parser tree-sitter language object. can use parser_parse() parse language specific text .","code":""},{"path":"/reference/parser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new parser — parser","text":"","code":"parser(language)"},{"path":"/reference/parser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new parser — parser","text":"language [tree_sitter_language] language object.","code":""},{"path":"/reference/parser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new parser — parser","text":"new parser.","code":""},{"path":"/reference/parser.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new parser — parser","text":"","code":"language <- treesitter.r::language() parser <- parser(language) parser #> <tree_sitter_parser> #> Language: r  text <- \"1 + foo\" tree <- parser_parse(parser, text) tree #> <tree_sitter_tree> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> 1 + foo #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 7)] #>   (binary_operator [(0, 0), (0, 7)] #>     lhs: (float [(0, 0), (0, 1)]) #>     operator: \"+\" [(0, 2), (0, 3)] #>     rhs: (identifier [(0, 4), (0, 7)]) #>   ) #> )"},{"path":"/reference/points.html","id":null,"dir":"Reference","previous_headings":"","what":"Points — points","title":"Points — points","text":"point() creates new tree-sitter point. point_row() point_column() access point's row column value, respectively. is_point() determines whether object point. Note points 0-indexed. typically easiest form work , since time provided row column information third party libraries, already 0-indexed. also consistent bytes, also 0-indexed often provided alongside corresponding points.","code":""},{"path":"/reference/points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Points — points","text":"","code":"point(row, column)  point_row(x)  point_column(x)  is_point(x)"},{"path":"/reference/points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Points — points","text":"row [double(1)] 0-indexed row place point . column [double(1)] 0-indexed column place point . x [tree_sitter_point] point.","code":""},{"path":"/reference/points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Points — points","text":"point() returns new point. point_row() point_column() return single double. is_point() returns TRUE FALSE.","code":""},{"path":"/reference/points.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Points — points","text":"","code":"x <- point(1, 2)  point_row(x) #> [1] 1 point_column(x) #> [1] 2  is_point(x) #> [1] TRUE"},{"path":"/reference/query-accessors.html","id":null,"dir":"Reference","previous_headings":"","what":"Query accessors — query-accessors","title":"Query accessors — query-accessors","text":"query_pattern_count() returns number patterns query. query_capture_count() returns number captures query. query_string_count() returns number string literals query. query_start_byte_for_pattern() query_end_byte_for_pattern() return byte ith pattern starts/ends query source.","code":""},{"path":"/reference/query-accessors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query accessors — query-accessors","text":"","code":"query_pattern_count(x)  query_capture_count(x)  query_string_count(x)  query_start_byte_for_pattern(x, i)  query_end_byte_for_pattern(x, i)"},{"path":"/reference/query-accessors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query accessors — query-accessors","text":"x [tree_sitter_query] query. [double(1)] ith pattern extract byte .","code":""},{"path":"/reference/query-accessors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Query accessors — query-accessors","text":"query_pattern_count(), query_capture_count(), query_string_count() return single double count value. query_start_byte_for_pattern() query_end_byte_for_pattern() return single double respective byte ith pattern, otherwise return NA.","code":""},{"path":"/reference/query-accessors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query accessors — query-accessors","text":"","code":"source <- '(binary_operator   lhs: (identifier) @lhs   operator: _ @operator   rhs: (function_definition) @rhs   (#eq? @lhs \"fn\") )' language <- treesitter.r::language()  query <- query(language, source)  query_pattern_count(query) #> [1] 1 query_capture_count(query) #> [1] 3 query_string_count(query) #> [1] 2  query_start_byte_for_pattern(query, 1) #> [1] 0 query_end_byte_for_pattern(query, 1) #> [1] 120  text <- \"   fn <- function() {}   fn2 <- function() {}   fn <- 5   fn <- function(a, b, c) { a + b + c } \" parser <- parser(language) tree <- parser_parse(parser, text) node <- tree_root_node(tree)  query_matches(query, node) #> [[1]] #> [[1]][[1]] #> [[1]][[1]]$name #> [1] \"lhs\"      \"operator\" \"rhs\"      #>  #> [[1]][[1]]$node #> [[1]][[1]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(1, 2), (1, 4)]) #>  #> [[1]][[1]]$node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(1, 5), (1, 7)] #>  #> [[1]][[1]]$node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() {} #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(1, 8), (1, 21)] #>   name: \"function\" [(1, 8), (1, 16)] #>   parameters: (parameters [(1, 16), (1, 18)] #>     open: \"(\" [(1, 16), (1, 17)] #>     close: \")\" [(1, 17), (1, 18)] #>   ) #>   body: (braced_expression [(1, 19), (1, 21)] #>     open: \"{\" [(1, 19), (1, 20)] #>     close: \"}\" [(1, 20), (1, 21)] #>   ) #> ) #>  #>  #>  #> [[1]][[2]] #> [[1]][[2]]$name #> [1] \"lhs\"      \"operator\" \"rhs\"      #>  #> [[1]][[2]]$node #> [[1]][[2]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(4, 2), (4, 4)]) #>  #> [[1]][[2]]$node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(4, 5), (4, 7)] #>  #> [[1]][[2]]$node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function(a, b, c) { a + b + c } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(4, 8), (4, 39)] #>   name: \"function\" [(4, 8), (4, 16)] #>   parameters: (parameters [(4, 16), (4, 25)] #>     open: \"(\" [(4, 16), (4, 17)] #>     parameter: (parameter [(4, 17), (4, 18)] #>       name: (identifier [(4, 17), (4, 18)]) #>     ) #>     (comma [(4, 18), (4, 19)]) #>     parameter: (parameter [(4, 20), (4, 21)] #>       name: (identifier [(4, 20), (4, 21)]) #>     ) #>     (comma [(4, 21), (4, 22)]) #>     parameter: (parameter [(4, 23), (4, 24)] #>       name: (identifier [(4, 23), (4, 24)]) #>     ) #>     close: \")\" [(4, 24), (4, 25)] #>   ) #>   body: (braced_expression [(4, 26), (4, 39)] #>     open: \"{\" [(4, 26), (4, 27)] #>     body: (binary_operator [(4, 28), (4, 37)] #>       lhs: (binary_operator [(4, 28), (4, 33)] #>         lhs: (identifier [(4, 28), (4, 29)]) #>         operator: \"+\" [(4, 30), (4, 31)] #>         rhs: (identifier [(4, 32), (4, 33)]) #>       ) #> <truncated> #>  #>  #>  #>"},{"path":"/reference/query-matches-and-captures.html","id":null,"dir":"Reference","previous_headings":"","what":"Query matches and captures — query-matches-and-captures","title":"Query matches and captures — query-matches-and-captures","text":"two functions execute query given node, return captures query use. functions return information, just structured differently depending use case. query_matches() returns captures first grouped pattern, grouped match within pattern. useful include multiple patterns query. query_captures() returns flat list captures ordered node location original text. normally easiest structure use single pattern without alternations benefit individual captures split match. also return capture name, .e. @name specified query.","code":""},{"path":"/reference/query-matches-and-captures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query matches and captures — query-matches-and-captures","text":"","code":"query_matches(x, node, ..., range = NULL)  query_captures(x, node, ..., range = NULL)"},{"path":"/reference/query-matches-and-captures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query matches and captures — query-matches-and-captures","text":"x [tree_sitter_query] query. node [tree_sitter_node] node run query . ... dots future extensions must empty. range [tree_sitter_range / NULL] optional range restrict query .","code":""},{"path":"/reference/query-matches-and-captures.html","id":"predicates","dir":"Reference","previous_headings":"","what":"Predicates","title":"Query matches and captures — query-matches-and-captures","text":"3 core types predicates supported: #eq? @capture \"string\" #eq? @capture1 @capture2 #match? @capture \"regex\" examples:   predicates can inverted - prefix.   predicates can converted style predicate style predicate - prefix. useful quantified captures, .e. (comment)+, + specifies \"one comment\".   full list possible predicate permutations: #eq? #-eq? #-eq? #--eq? #match? #-match? #-match? #--match?","code":"# Match an identifier named `\"name-of-interest\"` (   (identifier) @id   (#eq? @id \"name-of-interest\") )  # Match a binary operator where the left and right sides are the same name (   (binary_operator     lhs: (identifier) @id1     rhs: (identifier) @id2   )   (#eq? @id1 @id2) )  # Match a name with a `_` in it (   (identifier) @id   (#match? @id \"_\") ) (   (identifier) @id   (#not-eq? @id \"name-of-interest\") ) # Finds a block of comments where ALL comments are empty comments (   (comment)+ @comment   (#eq? @comment \"#\") )  # Finds a block of comments where ANY comments are empty comments (   (comment)+ @comment   (#any-eq? @comment \"#\") )"},{"path":"/reference/query-matches-and-captures.html","id":"string-double-quotes","dir":"Reference","previous_headings":"","what":"String double quotes","title":"Query matches and captures — query-matches-and-captures","text":"underlying tree-sitter predicate parser requires strings supplied query must use double quotes, .e. \"string\" 'string'. try use single quotes, get query error.","code":""},{"path":"/reference/query-matches-and-captures.html","id":"-match-regex","dir":"Reference","previous_headings":"","what":"#match? regex","title":"Query matches and captures — query-matches-and-captures","text":"regex support provided #match? powered grepl(). Escapes little tricky get right within match regex strings. use something like \\s regex string, need literal text \\\\s appear string tell tree-sitter regex engine escape backslash end just \\s captured string. requires putting two literal backslash characters R string , can accomplished either \"\\\\\\\\s\" using raw string like r'[\"\\\\\\\\s\"]' typically little easier. can also write queries separate file (typically called queries.scm) read R, also little straightforward can just write something like (#match? @id \"^\\\\s$\") read correctly.","code":""},{"path":"/reference/query-matches-and-captures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query matches and captures — query-matches-and-captures","text":"","code":"# --------------------------------------------------------------------------- # Simple query  text <- \" foo + b + a + ab and(a) \"  source <- \" (identifier) @id \"  language <- treesitter.r::language()  query <- query(language, source) parser <- parser(language) tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # A flat ordered list of captures, that's most useful here since # we only have 1 pattern! captures <- query_captures(query, node) captures$node #> [[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> foo #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(1, 0), (1, 3)]) #>  #> [[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> b #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(1, 6), (1, 7)]) #>  #> [[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> a #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(1, 10), (1, 11)]) #>  #> [[4]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> ab #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(1, 14), (1, 16)]) #>  #> [[5]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> and #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(2, 0), (2, 3)]) #>  #> [[6]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> a #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(2, 4), (2, 5)]) #>   # --------------------------------------------------------------------------- # Quantified query  text <- \" # this # that NULL  # and # here 1 + 1  # there 2 \"  # Find blocks of one or more comments # The `+` is a regex `+` meaning \"one or more\" comments in a row source <- \" (comment)+ @comment \"  language <- treesitter.r::language()  query <- query(language, source) parser <- parser(language) tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # The extra structure provided by `query_matches()` is useful here so # we can see the 3 distinct blocks of comments matches <- query_matches(query, node)  # We provided one query pattern, so lets extract that matches <- matches[[1]]  # 3 blocks of comments matches[[1]] #> $name #> [1] \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # this #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(1, 0), (1, 6)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # that #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(2, 0), (2, 6)]) #>  #>  matches[[2]] #> $name #> [1] \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # and #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(5, 0), (5, 5)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # here #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(6, 0), (6, 6)]) #>  #>  matches[[3]] #> $name #> [1] \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # there #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(9, 0), (9, 7)]) #>  #>   # --------------------------------------------------------------------------- # Multiple query patterns  # If you know you need to run multiple queries, you can run them all at once # in one pass over the tree by providing multiple query patterns.  text <- \" a <- 1 b <- function() {} c <- b \"  # Use an extra set of `()` to separate multiple query patterns source <- \" (   (identifier) @id ) (   (binary_operator) @binary ) \"  language <- treesitter.r::language()  query <- query(language, source) parser <- parser(language) tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # The extra structure provided by `query_matches()` is useful here so # we can separate the two queries matches <- query_matches(query, node)  # First query - all identifiers matches[[1]] #> [[1]] #> [[1]]$name #> [1] \"id\" #>  #> [[1]]$node #> [[1]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> a #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(1, 0), (1, 1)]) #>  #>  #>  #> [[2]] #> [[2]]$name #> [1] \"id\" #>  #> [[2]]$node #> [[2]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> b #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(2, 0), (2, 1)]) #>  #>  #>  #> [[3]] #> [[3]]$name #> [1] \"id\" #>  #> [[3]]$node #> [[3]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> c #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(3, 0), (3, 1)]) #>  #>  #>  #> [[4]] #> [[4]]$name #> [1] \"id\" #>  #> [[4]]$node #> [[4]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> b #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(3, 5), (3, 6)]) #>  #>  #>   # Second query - all binary operators matches[[2]] #> [[1]] #> [[1]]$name #> [1] \"binary\" #>  #> [[1]]$node #> [[1]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> a <- 1 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(1, 0), (1, 6)] #>   lhs: (identifier [(1, 0), (1, 1)]) #>   operator: \"<-\" [(1, 2), (1, 4)] #>   rhs: (float [(1, 5), (1, 6)]) #> ) #>  #>  #>  #> [[2]] #> [[2]]$name #> [1] \"binary\" #>  #> [[2]]$node #> [[2]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> b <- function() {} #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(2, 0), (2, 18)] #>   lhs: (identifier [(2, 0), (2, 1)]) #>   operator: \"<-\" [(2, 2), (2, 4)] #>   rhs: (function_definition [(2, 5), (2, 18)] #>     name: \"function\" [(2, 5), (2, 13)] #>     parameters: (parameters [(2, 13), (2, 15)] #>       open: \"(\" [(2, 13), (2, 14)] #>       close: \")\" [(2, 14), (2, 15)] #>     ) #>     body: (braced_expression [(2, 16), (2, 18)] #>       open: \"{\" [(2, 16), (2, 17)] #>       close: \"}\" [(2, 17), (2, 18)] #>     ) #>   ) #> ) #>  #>  #>  #> [[3]] #> [[3]]$name #> [1] \"binary\" #>  #> [[3]]$node #> [[3]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> c <- b #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (binary_operator [(3, 0), (3, 6)] #>   lhs: (identifier [(3, 0), (3, 1)]) #>   operator: \"<-\" [(3, 2), (3, 4)] #>   rhs: (identifier [(3, 5), (3, 6)]) #> ) #>  #>  #>   # --------------------------------------------------------------------------- # The `#eq?` and `#match?` predicates  text <- ' fn(a, b)  test_that(\"this\", {   test })  fn_name(args)  test_that(\"that\", {   test })  fn2_(args) '  language <- treesitter.r::language() parser <- parser(language) tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Use an extra set of outer `()` when you are applying a predicate to ensure # the query pattern is grouped with the query predicate. # This one finds all function calls where the function name is `test_that`. source <- ' (   (call     function: (identifier) @name   ) @call   (#eq? @name \"test_that\") ) '  query <- query(language, source)  # It's fine to have a flat list of captures here, but we probably want to # remove the `@name` captures and just retain the full `@call` captures. captures <- query_captures(query, node) captures$node[captures$name == \"call\"] #> [[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> test_that(\"this\", { #>   test #> }) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (call [(3, 0), (5, 2)] #>   function: (identifier [(3, 0), (3, 9)]) #>   arguments: (arguments [(3, 9), (5, 2)] #>     open: \"(\" [(3, 9), (3, 10)] #>     argument: (argument [(3, 10), (3, 16)] #>       value: (string [(3, 10), (3, 16)] #>         \"\\\"\" [(3, 10), (3, 11)] #>         content: (string_content [(3, 11), (3, 15)]) #>         \"\\\"\" [(3, 15), (3, 16)] #>       ) #>     ) #>     (comma [(3, 16), (3, 17)]) #>     argument: (argument [(3, 18), (5, 1)] #>       value: (braced_expression [(3, 18), (5, 1)] #>         open: \"{\" [(3, 18), (3, 19)] #>         body: (identifier [(4, 2), (4, 6)]) #>         close: \"}\" [(5, 0), (5, 1)] #>       ) #>     ) #>     close: \")\" [(5, 1), (5, 2)] #>   ) #> ) #>  #> [[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> test_that(\"that\", { #>   test #> }) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (call [(9, 0), (11, 2)] #>   function: (identifier [(9, 0), (9, 9)]) #>   arguments: (arguments [(9, 9), (11, 2)] #>     open: \"(\" [(9, 9), (9, 10)] #>     argument: (argument [(9, 10), (9, 16)] #>       value: (string [(9, 10), (9, 16)] #>         \"\\\"\" [(9, 10), (9, 11)] #>         content: (string_content [(9, 11), (9, 15)]) #>         \"\\\"\" [(9, 15), (9, 16)] #>       ) #>     ) #>     (comma [(9, 16), (9, 17)]) #>     argument: (argument [(9, 18), (11, 1)] #>       value: (braced_expression [(9, 18), (11, 1)] #>         open: \"{\" [(9, 18), (9, 19)] #>         body: (identifier [(10, 2), (10, 6)]) #>         close: \"}\" [(11, 0), (11, 1)] #>       ) #>     ) #>     close: \")\" [(11, 1), (11, 2)] #>   ) #> ) #>   # This one finds all functions with a `_` in their name. It uses the R # level `grepl()` for the regex processing. source <- ' (   (call     function: (identifier) @name   ) @call   (#match? @name \"_\") ) '  query <- query(language, source)  captures <- query_captures(query, node) captures$node[captures$name == \"call\"] #> [[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> test_that(\"this\", { #>   test #> }) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (call [(3, 0), (5, 2)] #>   function: (identifier [(3, 0), (3, 9)]) #>   arguments: (arguments [(3, 9), (5, 2)] #>     open: \"(\" [(3, 9), (3, 10)] #>     argument: (argument [(3, 10), (3, 16)] #>       value: (string [(3, 10), (3, 16)] #>         \"\\\"\" [(3, 10), (3, 11)] #>         content: (string_content [(3, 11), (3, 15)]) #>         \"\\\"\" [(3, 15), (3, 16)] #>       ) #>     ) #>     (comma [(3, 16), (3, 17)]) #>     argument: (argument [(3, 18), (5, 1)] #>       value: (braced_expression [(3, 18), (5, 1)] #>         open: \"{\" [(3, 18), (3, 19)] #>         body: (identifier [(4, 2), (4, 6)]) #>         close: \"}\" [(5, 0), (5, 1)] #>       ) #>     ) #>     close: \")\" [(5, 1), (5, 2)] #>   ) #> ) #>  #> [[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn_name(args) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (call [(7, 0), (7, 13)] #>   function: (identifier [(7, 0), (7, 7)]) #>   arguments: (arguments [(7, 7), (7, 13)] #>     open: \"(\" [(7, 7), (7, 8)] #>     argument: (argument [(7, 8), (7, 12)] #>       value: (identifier [(7, 8), (7, 12)]) #>     ) #>     close: \")\" [(7, 12), (7, 13)] #>   ) #> ) #>  #> [[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> test_that(\"that\", { #>   test #> }) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (call [(9, 0), (11, 2)] #>   function: (identifier [(9, 0), (9, 9)]) #>   arguments: (arguments [(9, 9), (11, 2)] #>     open: \"(\" [(9, 9), (9, 10)] #>     argument: (argument [(9, 10), (9, 16)] #>       value: (string [(9, 10), (9, 16)] #>         \"\\\"\" [(9, 10), (9, 11)] #>         content: (string_content [(9, 11), (9, 15)]) #>         \"\\\"\" [(9, 15), (9, 16)] #>       ) #>     ) #>     (comma [(9, 16), (9, 17)]) #>     argument: (argument [(9, 18), (11, 1)] #>       value: (braced_expression [(9, 18), (11, 1)] #>         open: \"{\" [(9, 18), (9, 19)] #>         body: (identifier [(10, 2), (10, 6)]) #>         close: \"}\" [(11, 0), (11, 1)] #>       ) #>     ) #>     close: \")\" [(11, 1), (11, 2)] #>   ) #> ) #>  #> [[4]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn2_(args) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (call [(13, 0), (13, 10)] #>   function: (identifier [(13, 0), (13, 4)]) #>   arguments: (arguments [(13, 4), (13, 10)] #>     open: \"(\" [(13, 4), (13, 5)] #>     argument: (argument [(13, 5), (13, 9)] #>       value: (identifier [(13, 5), (13, 9)]) #>     ) #>     close: \")\" [(13, 9), (13, 10)] #>   ) #> ) #>   # --------------------------------------------------------------------------- # The `any-` and `not-` predicate modifiers  text <- ' # 1 # # 2 NULL  # 3 # 4 NULL  # # NULL  # # 5 # # 6 # NULL '  language <- treesitter.r::language() parser <- parser(language) tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Two queries: # - Find comment blocks where there is at least one empty comment # - Find comment blocks where there is at least one non-empty comment source <- ' (   (comment)+ @comment   (#any-eq? @comment \"#\") ) (   (comment)+ @comment   (#any-not-eq? @comment \"#\") ) '  query <- query(language, source)  matches <- query_matches(query, node)  # Query 1 has 3 comment blocks that match query1 <- matches[[1]] query1[[1]] #> $name #> [1] \"comment\" \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 1 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(1, 0), (1, 3)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(2, 0), (2, 1)]) #>  #> $node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 2 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(3, 0), (3, 3)]) #>  #>  query1[[2]] #> $name #> [1] \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(10, 0), (10, 1)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(11, 0), (11, 1)]) #>  #>  query1[[3]] #> $name #> [1] \"comment\" \"comment\" \"comment\" \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(14, 0), (14, 1)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 5 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(15, 0), (15, 3)]) #>  #> $node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(16, 0), (16, 1)]) #>  #> $node[[4]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 6 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(17, 0), (17, 3)]) #>  #> $node[[5]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(18, 0), (18, 1)]) #>  #>   # Query 2 has 3 comment blocks that match (a different set than query 1!) query2 <- matches[[2]] query2[[1]] #> $name #> [1] \"comment\" \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 1 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(1, 0), (1, 3)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(2, 0), (2, 1)]) #>  #> $node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 2 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(3, 0), (3, 3)]) #>  #>  query2[[2]] #> $name #> [1] \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 3 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(6, 0), (6, 3)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 4 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(7, 0), (7, 3)]) #>  #>  query2[[3]] #> $name #> [1] \"comment\" \"comment\" \"comment\" \"comment\" \"comment\" #>  #> $node #> $node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(14, 0), (14, 1)]) #>  #> $node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 5 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(15, 0), (15, 3)]) #>  #> $node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(16, 0), (16, 1)]) #>  #> $node[[4]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # 6 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(17, 0), (17, 3)]) #>  #> $node[[5]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> # #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (comment [(18, 0), (18, 1)]) #>  #>"},{"path":"/reference/query.html","id":null,"dir":"Reference","previous_headings":"","what":"Queries — query","title":"Queries — query","text":"query() lets specify query source string use query_captures() query_matches(). source string written way somewhat similar idea capture groups regular expressions. write one query patterns match nodes tree, \"capture\" parts patterns @name tags. captures values returned query_captures() query_matches(). also series predicates can used refine query. described query_matches() help page. Read tree-sitter documentation learn query syntax.","code":""},{"path":"/reference/query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Queries — query","text":"","code":"query(language, source)"},{"path":"/reference/query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Queries — query","text":"language [tree_sitter_language] language. source [string] query source string.","code":""},{"path":"/reference/query.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Queries — query","text":"query.","code":""},{"path":"/reference/query.html","id":"storing-queries","dir":"Reference","previous_headings":"","what":"Storing queries","title":"Queries — query","text":"Query objects contain external pointers, saved disk reloaded. One consequence create build time inside package. example, precompile query may assume can create global variable package top level code like :   work two reasons: external query QUERY created package build time, longer valid package load time. version treesitter treesitter.r locked version used build time, rather package load time. correct way create query package load, like :   one place usage <<- acceptable.","code":"QUERY <- treesitter::query(treesitter.r::language(), \"query_source_text\") QUERY <- NULL  .onLoad <- function(libname, pkgname) {   QUERY <<- treesitter::query(treesitter.r::language(), \"query_source_text\") }"},{"path":"/reference/query.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Queries — query","text":"","code":"# This query looks for binary operators where the left hand side is an # identifier named `fn`, and the right hand side is a function definition. # The operator can be `<-` or `=` (technically it can also be things like # `+` as well in this example). source <- '(binary_operator   lhs: (identifier) @lhs   operator: _ @operator   rhs: (function_definition) @rhs   (#eq? @lhs \"fn\") )'  language <- treesitter.r::language()  query <- query(language, source)  text <- \"   fn <- function() {}   fn2 <- function() {}   fn <- 5   fn = function(a, b, c) { a + b + c } \" parser <- parser(language) tree <- parser_parse(parser, text) node <- tree_root_node(tree)  query_matches(query, node) #> [[1]] #> [[1]][[1]] #> [[1]][[1]]$name #> [1] \"lhs\"      \"operator\" \"rhs\"      #>  #> [[1]][[1]]$node #> [[1]][[1]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(1, 2), (1, 4)]) #>  #> [[1]][[1]]$node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(1, 5), (1, 7)] #>  #> [[1]][[1]]$node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() {} #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(1, 8), (1, 21)] #>   name: \"function\" [(1, 8), (1, 16)] #>   parameters: (parameters [(1, 16), (1, 18)] #>     open: \"(\" [(1, 16), (1, 17)] #>     close: \")\" [(1, 17), (1, 18)] #>   ) #>   body: (braced_expression [(1, 19), (1, 21)] #>     open: \"{\" [(1, 19), (1, 20)] #>     close: \"}\" [(1, 20), (1, 21)] #>   ) #> ) #>  #>  #>  #> [[1]][[2]] #> [[1]][[2]]$name #> [1] \"lhs\"      \"operator\" \"rhs\"      #>  #> [[1]][[2]]$node #> [[1]][[2]]$node[[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(4, 2), (4, 4)]) #>  #> [[1]][[2]]$node[[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> = #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"=\" [(4, 5), (4, 6)] #>  #> [[1]][[2]]$node[[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function(a, b, c) { a + b + c } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(4, 7), (4, 38)] #>   name: \"function\" [(4, 7), (4, 15)] #>   parameters: (parameters [(4, 15), (4, 24)] #>     open: \"(\" [(4, 15), (4, 16)] #>     parameter: (parameter [(4, 16), (4, 17)] #>       name: (identifier [(4, 16), (4, 17)]) #>     ) #>     (comma [(4, 17), (4, 18)]) #>     parameter: (parameter [(4, 19), (4, 20)] #>       name: (identifier [(4, 19), (4, 20)]) #>     ) #>     (comma [(4, 20), (4, 21)]) #>     parameter: (parameter [(4, 22), (4, 23)] #>       name: (identifier [(4, 22), (4, 23)]) #>     ) #>     close: \")\" [(4, 23), (4, 24)] #>   ) #>   body: (braced_expression [(4, 25), (4, 38)] #>     open: \"{\" [(4, 25), (4, 26)] #>     body: (binary_operator [(4, 27), (4, 36)] #>       lhs: (binary_operator [(4, 27), (4, 32)] #>         lhs: (identifier [(4, 27), (4, 28)]) #>         operator: \"+\" [(4, 29), (4, 30)] #>         rhs: (identifier [(4, 31), (4, 32)]) #>       ) #> <truncated> #>  #>  #>  #>"},{"path":"/reference/ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Ranges — ranges","title":"Ranges — ranges","text":"range() creates new tree-sitter range. range_start_byte() range_end_byte() access range's start end bytes, respectively. range_start_point() range_end_point() access range's start end points, respectively. is_range() determines whether object range. Note bytes points used ranges 0-indexed.","code":""},{"path":"/reference/ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ranges — ranges","text":"","code":"range(start_byte, start_point, end_byte, end_point)  range_start_byte(x)  range_start_point(x)  range_end_byte(x)  range_end_point(x)  is_range(x)"},{"path":"/reference/ranges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ranges — ranges","text":"start_byte, end_byte [double(1)] 0-indexed bytes start end range, respectively. start_point, end_point [tree_sitter_point] 0-indexed points start end range, respectively. x [tree_sitter_range] range.","code":""},{"path":"/reference/ranges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ranges — ranges","text":"range() returns new range. range_start_byte() range_end_byte() return single double. range_start_point() range_end_point() return point(). is_range() returns TRUE FALSE.","code":""},{"path":[]},{"path":"/reference/ranges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ranges — ranges","text":"","code":"x <- range(5, point(1, 3), 7, point(1, 5)) x #> <tree_sitter_range> #> Start <byte: 5, row: 1, column: 3> #> End <byte: 7, row: 1, column: 5>  range_start_byte(x) #> [1] 5 range_end_byte(x) #> [1] 7  range_start_point(x) #> <tree_sitter_point> #> Row: 1 #> Column: 3 range_end_point(x) #> <tree_sitter_point> #> Row: 1 #> Column: 5  is_range(x) #> [1] TRUE"},{"path":"/reference/text_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a snippet of text — text_parse","title":"Parse a snippet of text — text_parse","text":"text_parse() convenience utility quickly parsing small snippet text using particular language getting access root node. meant demonstration purposes. going need reparse text edit made, create full parser parser() use parser_parse() instead.","code":""},{"path":"/reference/text_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a snippet of text — text_parse","text":"","code":"text_parse(x, language)"},{"path":"/reference/text_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a snippet of text — text_parse","text":"x [string] text parse. language [tree_sitter_language] language parse .","code":""},{"path":"/reference/text_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a snippet of text — text_parse","text":"root node.","code":""},{"path":"/reference/text_parse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a snippet of text — text_parse","text":"","code":"language <- treesitter.r::language() text <- \"map(xs, function(x) 1 + 1)\"  # Note that this directly returns the root node, not the tree text_parse(text, language) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> map(xs, function(x) 1 + 1) #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 26)] #>   (call [(0, 0), (0, 26)] #>     function: (identifier [(0, 0), (0, 3)]) #>     arguments: (arguments [(0, 3), (0, 26)] #>       open: \"(\" [(0, 3), (0, 4)] #>       argument: (argument [(0, 4), (0, 6)] #>         value: (identifier [(0, 4), (0, 6)]) #>       ) #>       (comma [(0, 6), (0, 7)]) #>       argument: (argument [(0, 8), (0, 25)] #>         value: (function_definition [(0, 8), (0, 25)] #>           name: \"function\" [(0, 8), (0, 16)] #>           parameters: (parameters [(0, 16), (0, 19)] #>             open: \"(\" [(0, 16), (0, 17)] #>             parameter: (parameter [(0, 17), (0, 18)] #>               name: (identifier [(0, 17), (0, 18)]) #>             ) #>             close: \")\" [(0, 18), (0, 19)] #>           ) #>           body: (binary_operator [(0, 20), (0, 25)] #>             lhs: (float [(0, 20), (0, 21)]) #>             operator: \"+\" [(0, 22), (0, 23)] #>             rhs: (float [(0, 24), (0, 25)]) #>           ) #>         ) #> <truncated>"},{"path":"/reference/tree-accessors.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree accessors — tree-accessors","title":"Tree accessors — tree-accessors","text":"tree_text() retrieves tree's text parsed . tree_language() retrieves tree's language parsed . tree_included_ranges() retrieves tree's included_ranges provided parser_set_included_ranges(). Note ranges provided originally, still returns default always covers entire document.","code":""},{"path":"/reference/tree-accessors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree accessors — tree-accessors","text":"","code":"tree_included_ranges(x)  tree_text(x)  tree_language(x)"},{"path":"/reference/tree-accessors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree accessors — tree-accessors","text":"x [tree_sitter_tree] tree.","code":""},{"path":"/reference/tree-accessors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree accessors — tree-accessors","text":"tree_text() returns string. tree_language() returns tree_sitter_language. tree_included_ranges() returns list range() objects.","code":""},{"path":"/reference/tree-accessors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree accessors — tree-accessors","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"1 + foo\" tree <- parser_parse(parser, text)  tree_text(tree) #> [1] \"1 + foo\" tree_language(tree) #> <tree_sitter_language> #> Language: r tree_included_ranges(tree) #> [[1]] #> <tree_sitter_range> #> Start <byte: 0, row: 0, column: 0> #> End <byte: 4294967295, row: 4294967295, column: 4294967295> #>"},{"path":"/reference/tree_root_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the root node of the tree — tree_root_node","title":"Retrieve the root node of the tree — tree_root_node","text":"tree_root_node() entry point accessing nodes within specific tree. returns \"root\" tree, can use node_*() functions navigate around.","code":""},{"path":"/reference/tree_root_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the root node of the tree — tree_root_node","text":"","code":"tree_root_node(x)"},{"path":"/reference/tree_root_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the root node of the tree — tree_root_node","text":"x [tree_sitter_tree] tree.","code":""},{"path":"/reference/tree_root_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the root node of the tree — tree_root_node","text":"node.","code":""},{"path":"/reference/tree_root_node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the root node of the tree — tree_root_node","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text) node <- tree_root_node(tree)  # Trees and nodes have a similar print method, but you can # only use other `node_*()` functions on nodes. tree #> <tree_sitter_tree> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 26)] #>   (binary_operator [(0, 0), (0, 26)] #>     lhs: (identifier [(0, 0), (0, 2)]) #>     operator: \"<-\" [(0, 3), (0, 5)] #>     rhs: (function_definition [(0, 6), (0, 26)] #>       name: \"function\" [(0, 6), (0, 14)] #>       parameters: (parameters [(0, 14), (0, 16)] #>         open: \"(\" [(0, 14), (0, 15)] #>         close: \")\" [(0, 15), (0, 16)] #>       ) #>       body: (braced_expression [(0, 17), (0, 26)] #>         open: \"{\" [(0, 17), (0, 18)] #>         body: (binary_operator [(0, 19), (0, 24)] #>           lhs: (float [(0, 19), (0, 20)]) #>           operator: \"+\" [(0, 21), (0, 22)] #>           rhs: (float [(0, 23), (0, 24)]) #>         ) #>         close: \"}\" [(0, 25), (0, 26)] #>       ) #>     ) #>   ) #> ) node #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn <- function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (program [(0, 0), (0, 26)] #>   (binary_operator [(0, 0), (0, 26)] #>     lhs: (identifier [(0, 0), (0, 2)]) #>     operator: \"<-\" [(0, 3), (0, 5)] #>     rhs: (function_definition [(0, 6), (0, 26)] #>       name: \"function\" [(0, 6), (0, 14)] #>       parameters: (parameters [(0, 14), (0, 16)] #>         open: \"(\" [(0, 14), (0, 15)] #>         close: \")\" [(0, 15), (0, 16)] #>       ) #>       body: (braced_expression [(0, 17), (0, 26)] #>         open: \"{\" [(0, 17), (0, 18)] #>         body: (binary_operator [(0, 19), (0, 24)] #>           lhs: (float [(0, 19), (0, 20)]) #>           operator: \"+\" [(0, 21), (0, 22)] #>           rhs: (float [(0, 23), (0, 24)]) #>         ) #>         close: \"}\" [(0, 25), (0, 26)] #>       ) #>     ) #>   ) #> )  node |>   node_child(1) |>   node_children() #> [[1]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)]) #>  #> [[2]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> <- #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"<-\" [(0, 3), (0, 5)] #>  #> [[3]] #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> function() { 1 + 1 } #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (function_definition [(0, 6), (0, 26)] #>   name: \"function\" [(0, 6), (0, 14)] #>   parameters: (parameters [(0, 14), (0, 16)] #>     open: \"(\" [(0, 14), (0, 15)] #>     close: \")\" [(0, 15), (0, 16)] #>   ) #>   body: (braced_expression [(0, 17), (0, 26)] #>     open: \"{\" [(0, 17), (0, 18)] #>     body: (binary_operator [(0, 19), (0, 24)] #>       lhs: (float [(0, 19), (0, 20)]) #>       operator: \"+\" [(0, 21), (0, 22)] #>       rhs: (float [(0, 23), (0, 24)]) #>     ) #>     close: \"}\" [(0, 25), (0, 26)] #>   ) #> ) #>"},{"path":"/reference/tree_root_node_with_offset.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve an offset root node — tree_root_node_with_offset","title":"Retrieve an offset root node — tree_root_node_with_offset","text":"tree_root_node_with_offset() similar tree_root_node(), returned root node's position shifted given number bytes, rows, columns. function allows parse subset document parser_parse() self-contained document, later access syntax tree coordinate space larger document. Note underlying text within x offsetting . Instead, assume text provided parser_parse() already contained entire subset document care , offset providing far document beginning text .","code":""},{"path":"/reference/tree_root_node_with_offset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve an offset root node — tree_root_node_with_offset","text":"","code":"tree_root_node_with_offset(x, byte, point)"},{"path":"/reference/tree_root_node_with_offset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve an offset root node — tree_root_node_with_offset","text":"x [tree_sitter_tree] tree. byte, point [double(1), tree_sitter_point] byte point offset combination.","code":""},{"path":"/reference/tree_root_node_with_offset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve an offset root node — tree_root_node_with_offset","text":"offset root node.","code":""},{"path":"/reference/tree_root_node_with_offset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve an offset root node — tree_root_node_with_offset","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"fn <- function() { 1 + 1 }\" tree <- parser_parse(parser, text)  # If `text` was the whole document, you can just use `tree_root_node()` node <- tree_root_node(tree)  # If `text` represents a subset of the document, use # `tree_root_node_with_offset()` to be able to get positions in the # coordinate space of the original document. byte <- 5 point <- point(5, 0) node_offset <- tree_root_node_with_offset(tree, byte, point)  # The position of `fn` if you treat `text` as the whole document node |>   node_child(1) |>   node_child(1) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(0, 0), (0, 2)])  # The position of `fn` if you treat `text` as a subset of a larger document node_offset |>   node_child(1) |>   node_child(1) #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> fn #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (identifier [(5, 0), (5, 2)])"},{"path":"/reference/tree_walk.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a TreeCursor iterator — tree_walk","title":"Generate a TreeCursor iterator — tree_walk","text":"tree_walk() creates TreeCursor starting root node. can use \"walk\" tree efficiently using node_child() similar node functions.","code":""},{"path":"/reference/tree_walk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a TreeCursor iterator — tree_walk","text":"","code":"tree_walk(x)"},{"path":"/reference/tree_walk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a TreeCursor iterator — tree_walk","text":"x [tree_sitter_tree] tree.","code":""},{"path":"/reference/tree_walk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a TreeCursor iterator — tree_walk","text":"TreeCursor object.","code":""},{"path":"/reference/tree_walk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a TreeCursor iterator — tree_walk","text":"","code":"language <- treesitter.r::language() parser <- parser(language)  text <- \"1 + foo\" tree <- parser_parse(parser, text)  cursor <- tree_walk(tree)  cursor$goto_first_child() #> [1] TRUE cursor$goto_first_child() #> [1] TRUE cursor$node() #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> 1 #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> (float [(0, 0), (0, 1)]) cursor$goto_next_sibling() #> [1] TRUE cursor$node() #> <tree_sitter_node> #>  #> ── Text ─────────────────────────────────────────────────────────────── #> + #>  #> ── S-Expression ─────────────────────────────────────────────────────── #> \"+\" [(0, 2), (0, 3)]"},{"path":"/reference/treesitter-package.html","id":null,"dir":"Reference","previous_headings":"","what":"treesitter: Bindings to 'Tree-Sitter' — treesitter-package","title":"treesitter: Bindings to 'Tree-Sitter' — treesitter-package","text":"Provides bindings 'Tree-sitter', incremental parsing system programming tools. 'Tree-sitter' builds concrete syntax trees source files language, can efficiently update syntax trees source file edited. also includes robust error recovery system provides useful parse results even presence syntax errors.","code":""},{"path":[]},{"path":"/reference/treesitter-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"treesitter: Bindings to 'Tree-Sitter' — treesitter-package","text":"Maintainer: Davis Vaughan davis@posit.co contributors: Posit Software, PBC [copyright holder, funder] Tree-sitter authors (Tree-sitter C library) [copyright holder]","code":""},{"path":"/reference/x_tree_sitter_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper page for consistent documentation — x_tree_sitter_node","title":"Helper page for consistent documentation — x_tree_sitter_node","text":"Helper page consistent documentation","code":""},{"path":"/reference/x_tree_sitter_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper page for consistent documentation — x_tree_sitter_node","text":"x [tree_sitter_node] node.","code":""},{"path":"/reference/x_tree_sitter_parser.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper page for consistent documentation — x_tree_sitter_parser","title":"Helper page for consistent documentation — x_tree_sitter_parser","text":"Helper page consistent documentation","code":""},{"path":"/reference/x_tree_sitter_parser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper page for consistent documentation — x_tree_sitter_parser","text":"x [tree_sitter_parser] parser.","code":""},{"path":"/reference/x_tree_sitter_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper page for consistent documentation — x_tree_sitter_query","title":"Helper page for consistent documentation — x_tree_sitter_query","text":"Helper page consistent documentation","code":""},{"path":"/reference/x_tree_sitter_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper page for consistent documentation — x_tree_sitter_query","text":"x [tree_sitter_query] query.","code":""},{"path":"/reference/x_tree_sitter_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper page for consistent documentation — x_tree_sitter_tree","title":"Helper page for consistent documentation — x_tree_sitter_tree","text":"Helper page consistent documentation","code":""},{"path":"/reference/x_tree_sitter_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper page for consistent documentation — x_tree_sitter_tree","text":"x [tree_sitter_tree] tree.","code":""},{"path":"/news/index.html","id":"treesitter-020","dir":"Changelog","previous_headings":"","what":"treesitter 0.2.0","title":"treesitter 0.2.0","text":"CRAN release: 2025-04-08 New query_end_byte_for_pattern() (#22). query_captures() query_matches() gain support - style predicates (initial PR @kylebutts, #30). query_captures() query_matches() now expansive examples section (#30). Fixed issue #eq? predicates extra partial matches returned (#28). Updated tree-sitter v0.23.0 (#23). Removed usage non-API C calls (#33).","code":""},{"path":"/news/index.html","id":"treesitter-010","dir":"Changelog","previous_headings":"","what":"treesitter 0.1.0","title":"treesitter 0.1.0","text":"CRAN release: 2024-06-24 Initial CRAN submission.","code":""}]
